@(assignmentId: Long, problems: List[Problem])
<html>
    <head>
        <link rel="stylesheet" href="@routes.Assets.at("stylesheets/main.css")">

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
        <script src="@routes.Assets.at("javascripts/shortest-edit-script.js")"></script>

        <script>
            function populateUserIdSelection() {
                const userIdSelectionEl = document.getElementById('userIdSelection');

                var userIds;
                $.ajax({
                    url: '@services.routes.DataProvider.getUserIdsForAssignment(assignmentId)',
                    method: 'GET',
                    success: function (msg) {
                        try {
                            userIds = JSON.parse(msg);
                            for (var i = 0; i < userIds.length; i++) {
                                var userIdEl = document.createElement("option");
                                userIdEl.text = userIds[i];
                                userIdSelectionEl.add(userIdEl);
                            }

                            loadSubmissionsForSelectedUser();
                        } catch (e) {
                            prompt("Error:", "Error getting user IDs: " + e + "\n" +
                                    "Assignment ID was: @assignmentId");
                        }
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        prompt("Error:", "Error getting user IDs: " + JSON.stringify(XMLHttpRequest) + "\n" +
                                "Assignment ID was: @assignmentId");
                    }
                });
            }

            // Maps each problem's ID to an array of the student's submissions
            var problemIdToSubmissions = {};

            function loadSubmissionsForSelectedUser() {
                // Lock userIdSelectionEl to prevent this function from being called twice
                const userIdSelectionEl = document.getElementById('userIdSelection');
                userIdSelectionEl.disabled = true;

                const userId = userIdSelectionEl.value;
                @for(problem <- problems) {
                    // Lock the slider while the submissions corresponding to it are changed
                    var stateSelectionEl = document.getElementById('stateSelection-@problem.getProblemId()');
                    stateSelectionEl.disabled = true;

                    var stateEditScripts = [];
                    $.ajax({
                        url: '@services.routes.DataProvider.getSubmissions(problem.getProblemId(), "")' + userId,
                        method: 'GET',
                        success: function (submissions) {
                            try {
                                // Find the state edit scripts
                                var stateEditScriptsStack = [];
                                var previousSubmission;
                                while (submissions.length > 0) {
                                    var submission = submissions.pop();

                                    /*
                                     The newer submissions should have a number as the previous property
                                     If a submission's previous property is not a number, then automatically accept it
                                     */
                                    if (!submission.previous || isNaN(submission.previous)
                                            (previousSubmission && submission.submissionId === previousSubmission)) {
                                        stateEditScriptsStack.push(submission.content);
                                        previousSubmission = submission.previous;
                                    }
                                }

                                // Build the state from the edit scripts and store each version in the map
                                var state = "";
                                problemIdToSubmissions['@problem.getProblemId()'] = [];
                                while(stateEditScriptsStack.length > 0) {
                                    var editScript = stateEditScriptsStack.pop();
                                    // Don't apply edit script if state didn't change
                                    if (!editScript)
                                        continue;

                                    try {
                                        state = applyEditScript(state, editScript);

                                        problemIdToSubmissions['@problem.getProblemId()'].push(JSON.parse(state));
                                    } catch (e) {
                                        prompt("Error:", "State is corrupted: " + e + "\n" +
                                        "User ID was: " + userId + "\n" +
                                        "State was: " + state + "\n" +
                                        "Edit script that caused corruption was: " + editScript);
                                    }
                                }

                                // Reassign stateSelectionEl variable because it might have changed since the request
                                // was sent
                                stateSelectionEl = document.getElementById('stateSelection-@problem.getProblemId()');

                                // Change the slider's max value to the number of submissions minus one
                                stateSelectionEl.max =
                                        problemIdToSubmissions['@problem.getProblemId()'].length - 1;
                                stateSelectionEl.value = stateSelectionEl.max;
                                updateProblemState('@problem.getProblemId()');

                                stateSelectionEl.disabled = false;
                            } catch (e) {
                                prompt("Error:", "Error getting problem contents: " + e + "\n" +
                                        "User ID was: " + userId + "\n" +
                                        "Server message: " + JSON.stringify(msg));
                            }
                        },
                        error: function(XMLHttpRequest, textStatus, errorThrown) {
                            prompt("Error:", "Error getting problem contents: " + JSON.stringify(XMLHttpRequest) + "\n" +
                                    "User ID was: " + userId + "\n");
                        }
                    });

                }

                // TODO: Make this execute AFTER the last ajax call is done
                userIdSelectionEl.disabled = false;
            }

            function updateProblemState(problemid) {
                const problemIframe = document.getElementById('problemIframe-' + problemid);
                const stateSelectionEl = document.getElementById('stateSelection-' + problemid);

                const stateToRestore = problemIdToSubmissions[problemid][stateSelectionEl.value];

                problemIframe.contentWindow.postMessage({query: 'restoreState', state: stateToRestore}, '*');
            }

            window.onload = populateUserIdSelection;
        </script>

    </head>

    <body>
        <select id="userIdSelection" class="userIdSelection" onchange="loadSubmissionsForSelectedUser()">

        </select>

        @* Code to generate the iframes for problems *@
        @for(problem <- problems) {
            <input type="range" class="stateSelection" id="stateSelection-@problem.getProblemId()"
            oninput="updateProblemState('@problem.getProblemId()')" min="0" max="0">

            <iframe class='exercise-iframe'
            id="problemIframe-@problem.getProblemId()" src=@problem.getProblemUrl().trim() ></iframe>
        }
    </body>
</html>