@import scala.collection.mutable.ListBuffer
@(preFix: String, assignmentID: Long, userID: String, duration: Long, isInstructor: Boolean,
        problems: List[Problem], lisOutcomeServiceURL: String, lisResultSourcedID: String)

<head>
    <link rel="stylesheet" href="@routes.Assets.at("stylesheets/main.css")">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <script type="text/javascript">

        // Load the iframes for the problems of the assignment
        function loadProblems() {
            $.ajax({
                url: '@services.routes.DataProvider.getProblems(assignmentID)',
                method: 'GET',
                success: function (problems) {
                    var onloadPromises = [];
                    for (var i = 0; i < problems.length; i++) {
                        @if(!isInstructor) {
                            var highestScoreEl = document.createElement('div');
                            highestScoreEl.id = "highestScore-" + problems[i].problemId;
                            highestScoreEl.className = "highestScore message";

                            document.body.appendChild(highestScoreEl);
                        }

                        var problemIframe = document.createElement('iframe');
                        problemIframe.id = problems[i].problemId;
                        problemIframe.className = 'exercise-iframe';
                        problemIframe.src = problems[i].problemUrl;

                        onloadPromises.push(new Promise(function(resolve, reject) {
                            problemIframe.onload = function() {
                                resolve();
                            }
                        }));

                        document.body.appendChild(problemIframe);
                    }

                    // When all of the iframes are loaded, restore the states from the student's preivous submissions
                    Promise.all(onloadPromises)
                            .then(restoreStatesOfProblems)
                            .then(function() {
                                $('iframe').each(function(i, e) {
                                    $(e).on('load', function() {
                                        e.contentWindow.postMessage({query: 'docHeight', id: $(e).attr('id')}, '*')
                                    })
                                })
                            });
                },
                error: function(XMLHttpRequest) {
                    prompt("Error", "Error getting problems: " + JSON.stringify(XMLHttpRequest) + "\n" +
                            "Given Assignment ID: @assignmentID" + "\n" +
                            "Given User ID: @userID");
                }
            });
        }

        // Response from messages to iframe
        function receiveMessage(event) {
            if (event.data.request) { // It's a response
                if (event.data.request.query === 'docHeight') {
                    const newHeight = event.data.docHeight + 200;
                    $('#' + event.data.request.id).height(newHeight)
                }
                else if (event.data.request.query === 'getContent') {
                    const problemId = event.data.request.problemId;
                    const score = event.data.score;
                    const state = event.data.state;
                    sendScoreAndStateEditScriptToServer(problemId, score, state);
                }
            }
        }

        window.addEventListener("message", receiveMessage, false);


        window.onload = loadProblems;

        // Fix heights of iframes
        $(document).ready()

    </script>
        
    @if(!isInstructor) {        
        <script src="@routes.Assets.at("javascripts/shortest-edit-script.js")"></script>

        @* Score and state handlers *@
        <script type="text/javascript">

            /*
             This interval calls the function to request the updated states and scores of problems,
             that way if the score or the states changed, then we can report those changes to the server.
             */
            var updateStatesInterval = setInterval(updateStatesFromProblems, 10000);

            /*
             The states that the server currently has stored.
             This is used to compute what has changed since the last time data was sent to the server, so that the server
             only needs to store the changes every update instead of storing the whole state every update.
             */
            var problemIdToContent = {};

            // Sends the states of the problems that were previously submitted to the problems to be restored
            function restoreStatesOfProblems() {
                // TODO: change twirlapi for loop to an ajax request
                @for(problem <- problems) {
                    problemIdToContent["@problem.getProblemId()"] = {};

                    /*
                     Get student's submissions from server.
                     Each submission has the properties: submissionId, submittedAt, correct, maxscore, content, and previous
                     Content contains edit scripts that are used to build the state that the student had the problem in.
                     Previous contains the submissionId of the previous submissionId to chain the edit scripts together
                     in the correct order
                        i.e.
                            Suppose A, B, C, and D are submissionIds
                            Submissions could be received like this:
                                submissionId: A, previous: null,
                                submissionId: B, previous: A,
                                submissionId: C, previous: A,
                                submissionId: D, prevoius: B

                            This could happen if the student has two tabs open, and we want their latest changes,
                            so we keep track of both chains of submissions, and take the latest submission and work
                            backwards (D->B->A) to find the edit scripts, and then apply them (A->B->D) to rebuild the
                            state.
                      */
                    $.ajax({
                        url: '@services.routes.DataProvider.getSubmissions(problem.getProblemId(), userID)',
                        method: 'GET',
                        success: function (msg) {
                            try {
                                var submissions = msg.slice();
                                if (submissions.length <= 0)
                                    return;

                                // Find the state edit scripts and highest score
                                var stateEditScriptsStack = [];
                                var lastSubmission = submissions[submissions.length - 1];
                                var bestSubmission = lastSubmission;
                                var previousSubmissionId = lastSubmission.submissionId;
                                while (submissions.length > 0) {
                                    var submission = submissions.pop();

                                    /*
                                     The newer submissions should have a number as the previous property
                                     If a submission's previous property is not a number, then automatically accept it
                                      */
                                    if (!submission.previous || isNaN(submission.previous) ||
                                            (submission.submissionId == previousSubmissionId)) {
                                        stateEditScriptsStack.push(submission.content);
                                        previousSubmissionId = submission.previous;

                                        var scorePercent = (submission.correct / submission.maxscore) * 100.0;
                                        var highestScorePercent = bestSubmission ?
                                                (bestSubmission.correct / bestSubmission.maxscore) * 100.0 : 0.0;
                                        if (scorePercent >= highestScorePercent) {
                                            bestSubmission = submission;
                                        }
                                    }
                                }

                                updateHighestScoreDisplay(@problem.getProblemId(), bestSubmission);

                                // Build the state from the edit scripts and store each version in the map
                                var state = "";
                                while (stateEditScriptsStack.length > 0) {
                                    var editScript = stateEditScriptsStack.pop();

                                    // Don't apply edit script if state didn't change
                                    if (!editScript)
                                        continue;

                                    try {
                                        state = applyEditScript(state, editScript);
                                    } catch (e) {
                                        prompt("Error:", "State is corrupted: " + e + "\n" +
                                                "Problem ID was: @problem.getProblemId()" + "\n" +
                                                "User ID was: @userID" + "\n" +
                                                "State was: " + state + "\n" +
                                                "Edit script that caused corruption was: " + editScript);
                                    }
                                }

                                // If the state was empty, then don't try to restore it
                                if (!state)
                                    return;

                                // Updates the previous version of the problem content so that we will know what changed
                                problemIdToContent["@problem.getProblemId()"] = {
                                    submissionId: lastSubmission.submissionId,
                                    score: {
                                        correct: bestSubmission.correct,
                                        maxscore: bestSubmission.maxscore
                                    },
                                    state: state};

                                // Post message to iframe to populate the problem
                                var iframe = document.getElementById('@problem.getProblemId()');
                                iframe.contentWindow.postMessage({query: 'restoreState', state: JSON.parse(state)}, '*');
                            } catch (e) {
                                prompt("Error", "Error getting problem contents: " + e + "\n" +
                                        "Problem ID was: @problem.getProblemId()" + "\n" +
                                        "User ID was: @userID" + "\n" +
                                        "Submissions were: " + JSON.stringify(msg));
                            }
                        },
                        error: function(XMLHttpRequest, textStatus, errorThrown) {
                            alert("Error getting problem contents: " + JSON.stringify(XMLHttpRequest));
                        }
                    });

                }

                // document.getElementById("saveMyWorkButton").disabled = false;
            }

            // Tell the iframes to report their state back.
            function updateStatesFromProblems() {
                $('.exercise-iframe').each(function(_, iframe) {
                    iframe.contentWindow.postMessage({query: 'getContent', problemId: iframe.id}, '*');
                });
            }

            // If the state or the score changed since the last submission, then send the new state and score to the server
            function sendScoreAndStateEditScriptToServer(problemId, score, state) {
                if (!problemIdToContent.hasOwnProperty(problemId))
                    return;

                const previousScorePercent = problemIdToContent[problemId].score ?
                        problemIdToContent[problemId].score : 0.0;
                const currentScorePercent = score && score.correct && score.maxscore ?
                        (score.correct / score.maxscore) * 100.0 : 0.0;

                const previousStateString = problemIdToContent[problemId].state ?
                        problemIdToContent[problemId].state : "";
                const currentStateString = state ? JSON.stringify(state) : "";

                const previousSubmissionId = problemIdToContent[problemId].submissionId ?
                        problemIdToContent[problemId].submissionId : null;

                if (currentScorePercent > previousScorePercent || previousStateString !== currentStateString) {
                    const data = {
                        problemId: problemId,
                        score: score,
                        stateEditScript: shortestEditScript(previousStateString, currentStateString),
                        previousSubmissionId: previousSubmissionId
                    };

                    $.ajax({
                        url: '@preFix/submissions/@assignmentID/@userID',
                        method: 'POST',
                        contentType: 'application/json',
                        data: JSON.stringify(data),
                        success: function (submission) {
                            problemIdToContent[problemId] = {
                                submissionId: submission.submissionId,
                                score: {
                                    correct: currentScorePercent,
                                    maxscore: 100
                                },
                                state: currentStateString
                            };

                            updateHighestScoreDisplay(problemId, submission);
                        },
                        error: function(XMLHttpRequest, textStatus, errorThrown) {
                            prompt("Error:", "Error saving work: " + JSON.stringify(XMLHttpRequest) + "\n" +
                            "Problem ID was: " + problemId + "\n" +
                            "User ID was: @userID" + "\n" +
                            "Score was: " + JSON.stringify(score) + "\n" +
                            "Previous state was: " + previousStateString + "\n" +
                            "Current state was: " + currentStateString + "\n");
                        }
                    });
                }
            }

            // Update the highest score element to display the score from the given submission
            function updateHighestScoreDisplay(problemId, submission) {
                var highestScoreEl = document.getElementById('highestScore-' + problemId);
                highestScoreEl.innerHTML = "<p>Submission saved at: " + new Date(submission.submittedAt) +
                        " | Highest recorded score: <b>" + ((submission.correct / submission.maxscore) * 100.0) + "%</b></p>"
            }

            // Save work and report score
            function submitGrades() {
                updateStatesFromProblems();
                // setTimeout(location.href = "@preFix/send-score/@assignmentID/@userID", 1000);
                setTimeout(function () {
                    const data = {
                        assignment: @assignmentID,
                        user: "@userID",
                        lis_outcome_service_url: "@lisOutcomeServiceURL",
                        lis_result_sourcedid: "@lisResultSourcedID"
                    };
                    $.ajax({
                        url: '@preFix/sendScore',
                        method: 'POST',
                        contentType: 'application/json',
                        data: JSON.stringify(data),
                        success: function (msg) {
                            var response = $("#response");
                            response.html(msg);
                            response.show();
                            setTimeout(function () {
                                response.hide();
                            }, 20000);
                        },
                        error: function(XMLHttpRequest, textStatus, errorThrown) {
                            prompt("Error:", "Error submitting grades: " + JSON.stringify(XMLHttpRequest) + "\n" +
                            "Assignment ID was: " + @assignmentID + "\n" +
                            "User ID was: " + @userID);
                        }
                    });
                }, 1000)
            }

        </script>
    }
            
    @* Timed assignment specific code *@
    @if(duration != null && duration > 0L) {
        <script type="text/javascript">
            const durationInMilliseconds = @duration * 60 * 1000;

            var endTimeInMilliseconds;

            var timeLeftInterval;

            function initializeTimer() {
                var timerEl = document.createElement('div');
                timerEl.id = 'timer';
                timerEl.className = 'rightSidebar';
                document.body.appendChild(timerEl);

                $.ajax({
                    url: '@services.routes.DataProvider.getStartTimeInMilliseconds(assignmentID, userID)',
                    method: 'GET',
                    success: function (startTimeInMilliseconds) {
                        endTimeInMilliseconds = startTimeInMilliseconds + durationInMilliseconds;

                        updateTimeLeftDisplay();
                        timeLeftInterval = setInterval(updateTimeLeftDisplay, 1000);
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        prompt("Error:", "Error getting start time: " + JSON.stringify(XMLHttpRequest) + "\n" +
                                "AssignmentID:" + @assignmentID + "\n" +
                                "UserID:" + @userID);
                    }
                });
            }

            function updateTimeLeftDisplay() {
                var timeLeftObj = new Date();
                timeLeftObj.setTime(endTimeInMilliseconds - timeLeftObj.getTime());

                /*
                All hours and days will be put into minutes
                i.e. two hours and 30 minutes will turn into 150 minutes
                If seconds is less than 10, then we add a 0 in front
                 */
                const timeLeftMin = Math.floor((timeLeftObj.getTime() / 1000) / 60);
                const timeLeftSec = ((timeLeftObj.getSeconds() < 10) ? "0" : "") + timeLeftObj.getSeconds();

                var timerEl = document.getElementById('timer');

                timerEl.innerHTML = "Time Left: " + timeLeftMin + ":" + timeLeftSec;

                // Time is up, submit assignment
                if (timeLeftObj.getTime() <= 0) {
                    submitGrades();
                    deleteProblems();
                    timerEl.remove();

                    if (timeLeftInterval)
                        clearInterval(timeLeftInterval);

                    alert("You ran out of time, your work has been saved, and your assignment has been graded");
                }
            }

            // Delete the iframes of the problems in the assignment
            function deleteProblems() {
                var highestScoreEls = Array.from(document.getElementsByClassName('highestScore'));
                var problemIframes = Array.from(document.getElementsByClassName('exercise-iframe'));

                for (var i = 0; i < highestScoreEls.length; i++)
                    highestScoreEls[i].remove();

                for (var i = 0; i < problemIframes.length; i++)
                    problemIframes[i].remove();

                clearInterval(updateStatesInterval);
            }

            $(document).ready(initializeTimer);
        </script>
    }


</head>

<body>
    @if(isInstructor) {
        <p class="message">You are viewing this assignment as instructor.</p>
        <p>
            <a href="@routes.HomeController.showEditPage(assignmentID)">Edit Assignment</a> |
            <a href="@routes.HomeController.getSubmissionViewer(assignmentID)">View Submissions</a>
        </p>
    }

    @if(!isInstructor) {
        <p>
            If you are done with all questions, click on "Record my score" to save your score in the gradebook.
        </p>

        <button onclick="submitGrades()">Record my score</button> <span class="message" id='response'></span>
    }

</body>
