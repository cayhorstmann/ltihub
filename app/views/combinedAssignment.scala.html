@import scala.collection.mutable.ListBuffer
@(prefix: String, assignmentID: Long, userID: String, duration: Long, isInstructor: Boolean,
        lisOutcomeServiceURL: String, lisResultSourcedID: String)

<head>
    <link rel="stylesheet" href="@routes.Assets.at("stylesheets/main.css")">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <script type="text/javascript">
        var problems = null;
        // Load the iframes for the problems of the assignment
        function loadProblems() {
            $.ajax({
                url: '@services.routes.DataProvider.getProblems(assignmentID, userID, if (isInstructor) "Instructor" else "Student" )',
                method: 'GET',
                success: function (probs) {
                	problems = probs;                	
                    var onloadPromises = [];
                    for (let i = 0; i < problems.length; i++) {
                    	// TODO: Maybe put everything into a div?
                        // TODO: For instructors, show the group
                    	
                        var highestScoreEl = document.createElement('div');
                        highestScoreEl.id = "highestScore-" + problems[i].id;
                        highestScoreEl.className = "highestScore message";

                        document.body.appendChild(highestScoreEl);
                    	
                        let problemIframe = document.createElement('iframe');
                        problemIframe.id = problems[i].id;
                        problemIframe.className = 'exercise-iframe';
                        problemIframe.src = problems[i].url;

                        if (problems[i].timeRemaining > 0 && !problems[i].start) { // If never submitted, put up start button
                    		let timedDiv = $('<div id="timed-' + problems[i].id + '">This is a timed exercise. Once you start it, you must finish it in ' + 
                    	    		problems[i].duration + ' minutes. <br/><button id="start-' + problems[i].id + '">Start</button></div>');
                    		$('body').append(timedDiv);
                    	    $('#start-' + problems[i].id).click(function() {
                    	    	   $('#timed-' + problems[i].id).replaceWith(problemIframe);    	
                    	    })
                    	    
                    	} else if (problems[i].timeRemaining == 0) {
                   			$('body').append('<div>This is a timed exercise whose time has elapsed.</div>')
                   		} else {                    		
                   			document.body.appendChild(problemIframe);
                   		}
                        
                        $(problemIframe).on('load', function() {
                            var message = {query: 'docHeight', id: problems[i].id };
                            problemIframe.contentWindow.postMessage(message, '*');
                            restoreStateOfProblem(problems[i]);
                        })
                    }      
                },
                error: function(XMLHttpRequest) {
                    prompt("Error", "Error getting problems: " + JSON.stringify(XMLHttpRequest) + "\n" +
                            "Assignment ID: @assignmentID" + "\n" +
                            "User ID: @userID");
                }
            });
        }

        // Response from messages to iframe
        function receiveMessage(event) {
            if (event.data.request) { // It's a response
                if (event.data.request.query === 'docHeight') {                	
                    console.log('received ' + JSON.stringify(event.data));
                    const newHeight = event.data.docHeight + 200;
                    $('#' + event.data.request.id).height(newHeight)
                }
                else if (event.data.request.query === 'getContent') {
                    const problemId = event.data.request.problemId;
                    const score = event.data.score;
                    const state = event.data.state;
                    sendScoreAndStateEditScriptToServer(problemId, score, state);
                }
            }
        }

        window.addEventListener("message", receiveMessage, false);


        window.onload = loadProblems;
    </script>
        
    @if(isInstructor) {
    <script type="text/javascript">
        function restoreStateOfProblem(problem) {}
    </script>
    }               
        
    @if(!isInstructor) {        
        <script src="@routes.Assets.at("javascripts/shortest-edit-script.js")"></script>

        @* Score and state handlers *@
        <script type="text/javascript">

            /*
             This interval calls the function to request the updated states and scores of problems,
             that way if the score or the states changed, then we can report those changes to the server.
             */
            var updateStatesInterval = setInterval(updateStatesFromProblems, 10000);

            /*
             The states that the server currently has stored.
             This is used to compute what has changed since the last time data was sent to the server, so that the server
             only needs to store the changes every update instead of storing the whole state every update.
             */
            var problemIdToContent = {};

            function restoreStateOfProblem(problem) {
                /*
                 Get student's submissions from server.
                 Each submission has the properties: submissionId, submittedAt, score, content, and previous
                 Content contains edit scripts that are used to build the state that the student had the problem in.
                 Previous contains the submissionId of the previous submissionId to chain the edit scripts together
                 in the correct order
                    i.e.
                        Suppose A, B, C, and D are submissionIds
                        Submissions could be received like this:
                            submissionId: A, previous: 0,
                            submissionId: B, previous: A,
                            submissionId: C, previous: A,
                            submissionId: D, prevoius: B

                        This could happen if the student has two tabs open, and we want their latest changes,
                        so we keep track of both chains of submissions, and take the latest submission and work
                        backwards (D->B->A) to find the edit scripts, and then apply them (A->B->D) to rebuild the
                        state.
                  */
                $.ajax({
                    url: '@prefix/get-submissions/' + problem.id + '/@userID',
                    method: 'GET',
                    success: function (msg) {
                        var submissionId = 0;
                        var state = "";
                        var score = 0.0;
                        try {
                            var submissions = msg.slice();
                            if (submissions.length > 0) {
                             // Find the state edit scripts and highest score
                             var stateEditScriptsStack = [];
                             var highestScore = 0.0;
                             var lastSubmission = submissions[submissions.length - 1];
                             submissionId = lastSubmission.submissionId
                             score = lastSubmission.score
                             var previous = submissionId; // Want to pick up the last one
                             while (submissions.length > 0) {
                                 var submission = submissions.pop();
                                    highestScore = Math.max(highestScore, submission.score);
                                 if (previous == -1 || previous == submission.submissionId) { // TODO: Legacy
                                     stateEditScriptsStack.push(submission.content);
                                     previous = submission.previous;	
                                 }
                             }

                             updateHighestScoreDisplay(problem.id, lastSubmission.submittedAt, highestScore, -1); // TODO: Actual remaining time

                             // Build the state from the edit scripts and store each version in the map
                             while (stateEditScriptsStack.length > 0) {
                                 var editScript = stateEditScriptsStack.pop();

                                 // Don't apply edit script if state didn't change
                                 if (!editScript)
                                     continue;

                                 try {
                                     state = applyEditScript(state, editScript);
                                 } catch (e) {
                                     prompt("Error", "State is corrupted: " + e + "\n" +
                                             "Problem ID: " + problem.id + "\n" +
                                             "User ID: @userID" + "\n" +
                                             "State: " + state + "\n" +
                                             "Edit script that caused corruption: " + editScript);
                                 }
                             }
                            }

                            if (state) { // If the state was empty, then don't try to restore it
                                var iframe = document.getElementById('' + problem.id);
                                iframe.contentWindow.postMessage({query: 'restoreState', state: JSON.parse(state)}, '*');
                            }

                        } catch (e) {
                            prompt("Error", "Error getting problem contents: " + e + "\n" +
                                    "Problem ID: " + problem.id + "\n" +
                                    "User ID: @userID" + "\n" +
                                    "Submissions: " + JSON.stringify(msg));
                            submissionId = 0;
                            score = 0.0;
                            state = ""; 
                        }
                        // Initializes the problem content so that it can be saved
                        problemIdToContent[problem.id] = {
                            submissionId: submissionId,
                            score: score,
                            state: state
                        };                                
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        alert("Error getting problem contents: " + JSON.stringify(XMLHttpRequest));
                        // Initializes the problem content so that it can be saved
                        problemIdToContent[problem.id] = {
                            submissionId: submissionId,
                            score: 0.0,
                            state: ""
                        };                                
                    }
                });
            }
         

            // Tell the iframes to report their state back.
            function updateStatesFromProblems() {
                $('.exercise-iframe').each(function(_, iframe) {
                    iframe.contentWindow.postMessage({query: 'getContent', problemId: iframe.id}, '*');
                });
            }
            
            // If the state or the score changed since the last submission, then send the new state and score to the server
            function sendScoreAndStateEditScriptToServer(problemId, score, state) {            	
                if (!problemIdToContent.hasOwnProperty(problemId)) // Haven't yet received first state
                    return;

                const previousScore = problemIdToContent[problemId].score;
                const currentCorrect = score.errors ? Math.max(score.correct - score.errors, 0) : score.correct;
                const currentScore = score && score.correct && score.maxscore ?
                        currentCorrect / score.maxscore : 0.0;

                const previousStateString = problemIdToContent[problemId].state;
                const currentStateString = state ? JSON.stringify(state) : "";

                /* TODO: Or if it is a timed problem that has not yet elapsed */
                
                if (currentScore !== previousScore || previousStateString !== currentStateString) {
                    const data = {
                        problemId: problemId,
                        correct: currentCorrect,
                        maxscore: score.maxscore,
                        stateEditScript: shortestEditScript(previousStateString, currentStateString),
                        previous: problemIdToContent[problemId].submissionId,
                        assignmentId: @assignmentID,
                        userId: "@userID"
                    };
                    
                    /* TODO: Get the time remaining for timed problem from server and display it as well */

                    $.ajax({
                        url: '@prefix/submissions',
                        method: 'POST',
                        contentType: 'application/json',
                        data: JSON.stringify(data),
                        success: function (result) {
                            problemIdToContent[problemId] = {
                                submissionId: result.submissionId,
                                score: currentScore,
                                state: currentStateString
                            };

                            updateHighestScoreDisplay(problemId, result.submittedAt, result.highestScore, result.timeRemaining);
                        },
                        error: function(XMLHttpRequest, textStatus, errorThrown) {
                            prompt("Error", "Error saving work: " + JSON.stringify(XMLHttpRequest) + "\n" +
                            "Problem ID: " + problemId + "\n" +
                            "User ID: @userID" + "\n" +
                            "Score: " + JSON.stringify(score) + "\n" +
                            "Previous state: " + previousStateString + "\n" +
                            "Current state: " + currentStateString + "\n");
                        }
                    });
                }
            }

            function formatTime(time) {
            	if (time <= 0) return "0 seconds";
            	else if (time >= 60 * 1000) return Math.round(time / (60 * 1000)) + " minutes";            	
            	else return Math.round(time / 1000) + " seconds";  
            }
            
            // Update the highest score element to display the score from the given submission
            function updateHighestScoreDisplay(problemId, submittedAt, highestScore, timeRemaining) {
                var highestScoreEl = document.getElementById('highestScore-' + problemId);
                highestScoreEl.innerHTML = "<p>Submission saved at: " + new Date(submittedAt) + 
                        "</p><p>Highest recorded score: <b>" + (highestScore * 100.0) + "%</b></p>" + 
                        (timeRemaining >= 0 ? "<p>Time remaining: " + formatTime(timeRemaining) + "</p>" : "")
            }
                       

            // Save work and report score
            function submitGrades() {
                updateStatesFromProblems();
                setTimeout(function () {
                	$("#response").hide();
                    const data = {
                        assignment: @assignmentID,
                        user: "@userID",
                        lis_outcome_service_url: "@lisOutcomeServiceURL",
                        lis_result_sourcedid: "@lisResultSourcedID"
                    };
                    $.ajax({
                        url: '@prefix/sendScore',
                        method: 'POST',
                        contentType: 'application/json',
                        data: JSON.stringify(data),
                        success: function (msg) {
                            var response = $("#response");
                            response.html(msg);
                            response.show();
                        },
                        error: function(XMLHttpRequest, textStatus, errorThrown) {
                            prompt("Error", "Error submitting grades: " + JSON.stringify(XMLHttpRequest) + "\n" +
                            "Assignment ID: " + @assignmentID + "\n" +
                            "User ID: " + @userID);
                        }
                    });
                }, 1000)
            }

        </script>
    }
            
    @* Timed assignment specific code *@
    @if(duration != null && duration > 0L) {
        <script type="text/javascript">
            const durationInMilliseconds = @duration * 60 * 1000; // TODO: Combine with timed problem code
            var endTimeInMilliseconds;
            var timeLeftInterval;
            var alertedTimeIsUp = false;

            function initializeTimer() {
                var timerEl = document.createElement('div');
                timerEl.id = 'timer';
                timerEl.className = 'rightSidebar';
                document.body.appendChild(timerEl);
                var currentTimeOnClient = new Date().getTime();
                $.ajax({
                    url: '@services.routes.DataProvider.getStartTimeInMilliseconds(assignmentID, userID)',
                    method: 'GET',
                    success: function (result) {
                    	var timeSpent = result.current - result.start
                    	var timeLeft = durationInMilliseconds - timeSpent
                        endTimeInMilliseconds = currentTimeOnClient + timeLeft;
                        updateTimeLeftDisplay();
                        timeLeftInterval = setInterval(updateTimeLeftDisplay, 1000);
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        prompt("Error", "Error getting start time: " + JSON.stringify(XMLHttpRequest) + "\n" +
                                "Assignment ID: " + @assignmentID + "\n" +
                                "User ID: " + @userID);
                    }
                });
            }

            function updateTimeLeftDisplay() {
                var timerEl = document.getElementById('timer');
                var timeLeftObj = new Date();
                timeLeftObj.setTime(endTimeInMilliseconds - timeLeftObj.getTime());

                // Time is up, submit assignment
                if (timeLeftObj.getTime() <= 0) {
                    if (!alertedTimeIsUp) {
                        alertedTimeIsUp = true;
                        submitGrades();
                        deleteProblems();
                        if (timerEl) 
                            timerEl.remove();

                        if (timeLeftInterval)
                            clearInterval(timeLeftInterval);
                        alert("You used up your time, your work has been saved, and your assignment has been graded");
                    }
                } else {
	                /*
	                All hours and days will be put into minutes
	                i.e. two hours and 30 minutes will turn into 150 minutes
	                If seconds is less than 10, then we add a 0 in front
	                 */
	                const timeLeftMin = Math.floor((timeLeftObj.getTime() / 1000) / 60);
	                const timeLeftSec = ((timeLeftObj.getSeconds() < 10) ? "0" : "") + timeLeftObj.getSeconds();
	
	                timerEl.innerHTML = "Time Left: " + timeLeftMin + ":" + timeLeftSec;
                }
            }

            // Delete the iframes of the problems in the assignment
            function deleteProblems() {
                var highestScoreEls = Array.from(document.getElementsByClassName('highestScore'));
                var problemIframes = Array.from(document.getElementsByClassName('exercise-iframe'));

                for (var i = 0; i < highestScoreEls.length; i++)
                    highestScoreEls[i].remove();

                for (var i = 0; i < problemIframes.length; i++)
                    problemIframes[i].remove();

                clearInterval(updateStatesInterval);
            }

            $(document).ready(initializeTimer);
        </script>
    }


</head>

<body>
    @if(isInstructor) {
        <p class="message">You are viewing this assignment as instructor.</p>
        <p>
            <a href="@routes.HomeController.showEditPage(assignmentID)">Edit Assignment</a> |
            <a href="@routes.HomeController.getSubmissionViewer(assignmentID)">View Submissions</a>
        </p>
    }

    @if(!isInstructor) {
        <div id="record-score">
        <p>
            If you are done with all questions, click on "Record my score" to save your score in the gradebook.
        </p>

        <button onclick="submitGrades()">Record my score</button> <span style='display:none' class='message' id='response'></span>
        </div>
    }

</body>
