@import scala.collection.mutable.ListBuffer
@(prefix: String, assignmentId: Long, userId: String, 
	toolConsumerId: String, contextId: String,  
	duration: Int, isInstructor: Boolean,
    lisOutcomeServiceURL: String, lisResultSourcedId: String,
    oauthConsumerKey: String)

<head>
    <link rel="stylesheet" href='@routes.Assets.at("stylesheets/main.css")'>

    <script type="text/javascript">
        // TODO: Do something better with the nanosecond time API
        var clientStampCounter = 0
    	function getClientStamp() {
    		clientStampCounter++;
    		return new Date().getTime() + clientStampCounter;
    	}
    
        var problems = null;
        // Load the iframes for the problems of the assignment
        function loadProblems() {
            const url = '@controllers.routes.DataProvider.getProblems(assignmentId, userId, toolConsumerId,
                		contextId, if (isInstructor) "Instructor" else "Student" )'
			const xhr = new XMLHttpRequest()
			xhr.responseType = 'json'			
    		xhr.addEventListener('load', event => {        		            
            	const problems = xhr.response;                	
                for (let i = 0; i < problems.length; i++) {
                	// TODO: Maybe put everything into a div?
                    // TODO: For instructors, show the group
                	
                    var highestScoreEl = document.createElement('div');
                    highestScoreEl.id = "highestScore-" + problems[i].id;
                    highestScoreEl.className = "highestScore message";

                    document.body.appendChild(highestScoreEl);
                	
                    let problemIframe = document.createElement('iframe');
                    problemIframe.id = problems[i].id;
                    problemIframe.className = 'exercise-iframe';
                    problemIframe.src = problems[i].url;
					document.body.appendChild(problemIframe);
					
                    problemIframe.addEventListener('load', function() {
                        var message = {query: 'docHeight', id: problems[i].id };
                        problemIframe.contentWindow.postMessage(message, '*');
                        restoreStateOfProblem(problems[i]);
                    })                        
                }
            })
    		xhr.addEventListener('error', event => {        		            
                console.log("Error getting problems from " + url);
            })
			xhr.open('GET', url)
			xhr.send()                            
        }

        // Response from messages to iframe
        function receiveMessage(event) {
            if (event.data.request) { // It's a response
                if (event.data.request.query === 'docHeight') {                	
                    console.log('received ' + JSON.stringify(event.data));
                    const newHeight = event.data.docHeight + 200;
                    document.getElementById(event.data.request.id).style.height = newHeight + 'px'
                }
                else if (event.data.request.query === 'getContent') {
                    const problemId = event.data.request.problemId;
                    const score = event.data.score;
                    const state = event.data.state;
                    sendScoreAndState(problemId, score, state);
                }
            }
        }

        window.addEventListener("message", receiveMessage, false);

        window.onload = loadProblems;
    </script>
        
    @if(isInstructor) {
    <script type="text/javascript">
        function restoreStateOfProblem(problem) {}
    </script>
    }               
        
    @if(!isInstructor) {        
        @* Score and state handlers *@
        <script type="text/javascript">

            /*
             Periodically calls the function to request the updated states and scores of problems,
             that way if the score or the states changed, then we can report those changes to the server.
            */
            var updateStatesInterval = setInterval(updateStatesFromProblems, 60 * 1000);

            var problemIdToContent = {};

            function restoreStateOfProblem(problem) {
                const url = '@prefix/getWork/' + problem.id + '/@userId/@toolConsumerId/@contextId'
				const xhr = new XMLHttpRequest()
				xhr.responseType = 'json'
				
    			xhr.addEventListener('load', event => {
    				const result = xhr.response        		            
                    problemIdToContent[problem.id] = {
               			score: result.score,
                   		state: result.state
                    }
                    if (result.state) { // If the state was empty, then don't try to restore it
                        var iframe = document.getElementById('' + problem.id);
                        iframe.contentWindow.postMessage({query: 'restoreState', state: JSON.parse(result.state)}, '*');
                    }
                    updateHighestScoreDisplay(problem.id, result.submittedAt, result.score);
                })
    			xhr.addEventListener('error', event => {
                    console.log("Error getting problem contents from " + url);
                    // Initializes the problem content so that it can be saved
                    problemIdToContent[problem.id] = {
                        score: 0,
                        state: "",
                    }                                
                })
    			xhr.open('GET', url)
    			xhr.send()                                
            }
         

            // Tell the iframes to report their state back.
            function updateStatesFromProblems() {
                for (const iframe of document.getElementsByClassName('exercise-iframe')) {
                    iframe.contentWindow.postMessage({query: 'getContent', problemId: iframe.id}, '*');
                }
            }
            
            // If the state or the score changed since the last submission or this is a timed problem, then send the new state and score to the server
            function sendScoreAndState(problemId, score, state) {            	
                if (!problemIdToContent.hasOwnProperty(problemId)) // Haven't yet received first state
                    return;

                const previousScore = problemIdToContent[problemId].score;
                const currentCorrect = score.errors ? Math.max(score.correct - score.errors, 0) : score.correct;
                const currentScore = score && score.correct && score.maxscore ?
                        currentCorrect / score.maxscore : 0.0;

                const previousStateString = problemIdToContent[problemId].state;
                const currentStateString = state ? JSON.stringify(state) : "";                
                
                if (currentScore !== previousScore || previousStateString !== currentStateString) {
                    const data = {
                        problemId: problemId,
                        score: currentScore,
                        state: currentStateString,
                        assignmentId: @assignmentId,
                        userId: "@userId",
                        toolConsumerId: "@toolConsumerId",
                        contextId: "@contextId",
                        clientStamp: getClientStamp()
                    };
                    
					const url = '@prefix/addSubmission'
					
					const xhr = new XMLHttpRequest()
					xhr.responseType = 'json'
    	    		xhr.addEventListener('load', event => {        		    
						const result = xhr.response
                        problemIdToContent[problemId] = {
                            score: currentScore,
                            state: currentStateString,
                        };

                        updateHighestScoreDisplay(problemId, result.submittedAt, result.highestScore);
                    })
                    
    	    		xhr.addEventListener('load', error => {        		    
                        console.log("Error saving work: " + JSON.stringify(data) + "\n" +
	                        "Problem ID: " + problemId + "\n" +
	                        "User ID: @userId" + "\n" +
	                        "Score: " + JSON.stringify(score) + "\n" +
	                        "Previous state: " + previousStateString + "\n" +
	                        "Current state: " + currentStateString + "\n");
                    })
        			xhr.open('POST', url)
                    xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');
        			xhr.send(JSON.stringify(data))                                     
                }
            }

            function formatTime(time) {
            	if (time <= 0) return "0 seconds";
            	else if (time >= 60 * 1000) return Math.round(time / (60 * 1000)) + " minutes";            	
            	else return Math.round(time / 1000) + " seconds";  
            }
            
            // Update the highest score element to display the score from the given submission
            function updateHighestScoreDisplay(problemId, submittedAt, highestScore) {
                var highestScoreEl = document.getElementById('highestScore-' + problemId);
                highestScoreEl.innerHTML = (submittedAt ? "<p>Submission saved at: " + new Date(submittedAt) : "") + 
                        "</p><p>Highest recorded score: <b>" + (highestScore * 100.0).toFixed(2) + "%</b></p>"
            }
                       

            // Save work and report score
            function submitGrades() {
                updateStatesFromProblems();
                setTimeout(function () {
                	document.getElementById("response").style.display = "none";
                    const data = {
                        assignmentId: @assignmentId,
                        userId: "@userId",
                        toolConsumerId: "@toolConsumerId",
                        contextId: "@contextId",
                        lisOutcomeServiceUrl: "@lisOutcomeServiceURL",
                        lisResultSourcedId: "@lisResultSourcedId",
                        oauthConsumerKey: "@oauthConsumerKey"
                    };
                    const url = '@prefix/sendScore'
					const xhr = new XMLHttpRequest()
    	    		xhr.addEventListener('load', event => {        		    
                        const response = document.getElementById("response");
                        response.innerHTML = xhr.responseText;
                        response.style.display = "block";
                    })
    	    		xhr.addEventListener('error', event => {        		    
                        console.log("Error submitting grades: " + JSON.stringify(data) + "\n" +
                            "Assignment ID: @assignmentId\n" +
                            "User ID: @userId");
                    })
        			xhr.open('POST', url)
                    xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');
        			xhr.send(JSON.stringify(data))                                     
                }, 1000)
            }

        </script>
    }
            
    @* Timed assignment specific code *@
    @if(duration > 0) {
        <script type="text/javascript">
            const durationInMilliseconds = @duration * 60 * 1000; 
            var endTimeInMilliseconds;
            var timeLeftInterval;
            var alertedTimeIsUp = false;

            function initializeTimer() {
                var timerEl = document.createElement('div');
                timerEl.id = 'timer';
                timerEl.className = 'rightSidebar';
                document.body.appendChild(timerEl);
                var currentTimeOnClient = new Date().getTime();
                
                const url = '@controllers.routes.DataProvider.getStartTimeInMilliseconds(assignmentId, userId, toolConsumerId, contextId)'
                const xhr = new XMLHttpRequest()
				xhr.responseType = 'json'
                
	    		xhr.addEventListener('load', event => {
        	        const result = xhr.response
                	var timeSpent = result.current - result.start
                	var timeLeft = durationInMilliseconds - timeSpent
                    endTimeInMilliseconds = currentTimeOnClient + timeLeft;
                    updateTimeLeftDisplay();
                    timeLeftInterval = setInterval(updateTimeLeftDisplay, 1000);
                })
	    		xhr.addEventListener('error', event => {
                    console.log("Error getting start time from " + url);
                })
    			xhr.open('GET', url)
    			xhr.send()                                
            }

            function updateTimeLeftDisplay() {
                var timerEl = document.getElementById('timer');
                var timeLeftObj = new Date();
                timeLeftObj.setTime(endTimeInMilliseconds - timeLeftObj.getTime());

                // Time is up, submit assignment
                if (timeLeftObj.getTime() <= 0) {
                    if (!alertedTimeIsUp) {
                        alertedTimeIsUp = true;
                        submitGrades();
                        deleteProblems();
                        if (timerEl) 
                            timerEl.remove();

                        if (timeLeftInterval)
                            clearInterval(timeLeftInterval);
                        alert("You used up your time, your work has been saved, and your assignment has been graded");
                    }
                } else {
	                /*
	                All hours and days will be put into minutes
	                i.e. two hours and 30 minutes will turn into 150 minutes
	                If seconds is less than 10, then we add a 0 in front
	                 */
	                const timeLeftMin = Math.floor((timeLeftObj.getTime() / 1000) / 60);
	                const timeLeftSec = ((timeLeftObj.getSeconds() < 10) ? "0" : "") + timeLeftObj.getSeconds();
	
	                timerEl.innerHTML = "Time Left: " + timeLeftMin + ":" + timeLeftSec;
                }
            }

            // Delete the iframes of the problems in the assignment
            function deleteProblems() {
                var highestScoreEls = Array.from(document.getElementsByClassName('highestScore'));
                var problemIframes = Array.from(document.getElementsByClassName('exercise-iframe'));

                for (var i = 0; i < highestScoreEls.length; i++)
                    highestScoreEls[i].remove();

                for (var i = 0; i < problemIframes.length; i++)
                    problemIframes[i].remove();

                clearInterval(updateStatesInterval);
            }

            document.addEventListener('DOMContentLoaded', initializeTimer);
        </script>
    }


</head>

<body>
    @if(isInstructor) {
        <p class="message">You are viewing this assignment as instructor.</p>
        <p>
            <a href="@routes.HomeController.getSubmissionViewer(assignmentId)">View Submissions</a>
        </p>
    }

    @if(!isInstructor) {
        <div id="record-score">
        <p>
            If you are done with all questions, click on "Record my score" to save your score in the gradebook.
        </p>

        <button onclick="submitGrades()">Record my score</button> <span style='display:none' class='message' id='response'></span>
        </div>
    }
<hr/>
<p>User ID: <code>@userId</code></p>
<p>Assignment ID: <code>@assignmentId</code></p>
</body>
