@import scala.collection.mutable.ListBuffer
@(preFix: String, assignmentID: Long, userID: String, duration: Long, isInstructor: Boolean,
        problems: List[Problem], problemIdToSubmissionWithMostCorrect: Map[Long, Submission])

<link rel="stylesheet" href="@routes.Assets.at("stylesheets/main.css")">

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="@routes.Assets.at("javascripts/shortest-edit-script.js")"></script>

@* Score and state handlers *@
<script type="text/javascript">
        /*
         The states that the server currently has stored.
         This is used to compute what has changed since the last time data was sent to the server, so that the server
         only needs to store the changes every update instead of storing the whole state every update.
         */
        var problemIdToContent = {};

        // Sends the states of the problems that were previously submitted to the problems to be restored
        function restoreStatesOfProblems() {
            @for(problem <- problems) {
                // Get student's most recently submitted work as a series of changes
                var stateEditScripts = @Html@{
                    val stateEditScriptsList = ListBuffer.empty[String];

                    val submissions = problem.getSubmissions().sortWith(_.getSubmissionId < _.getSubmissionId);
                    if (!submissions.isEmpty()) {
                        for (submission <- submissions) {
                            if (submission.getStudentId().equals(userID)
                            && submission.getContent() != null
                            && !submission.getContent().isEmpty()) {
                                stateEditScriptsList += submission.getContent();
                            }
                        }
                    }

                   stateEditScriptsList.mkString("[", ", ", "]");
                };

                // Didn't find submission for given studentID/problemID
                if (!stateEditScripts || stateEditScripts.length === 0) {
                    problemIdToContent["@problem.getProblemId()"] = {};
                // Rebuild state using edit scripts
                } else {
                    var state = "";
                    for (var i = 0; i < stateEditScripts.length; i++) {
                        var editScript = stateEditScripts[i];

                        state = applyEditScript(state, editScript);
                        console.log("i=" + i + ",editScript=" + editScript + ",state=" + state);
                    }
                    try {
                        state = JSON.parse(state);

                        // Updates the previous version of the problem content so that we will know what changed
                        problemIdToContent["@problem.getProblemId()"] = {score: "", state: JSON.stringify(state)};

                        // Post message to iframe to populate the problem
                        var iframe = document.getElementById('@problem.getProblemId()');
                        iframe.contentWindow.postMessage({query: 'restoreState', state: state}, '*');
                    }
                    catch (e) {
                    	console.log("Parse failed: " + e);
                        problemIdToContent["@problem.getProblemId()"] = {};
                    }
                }

            }


            setInterval(updateStatesFromProblems, 10000);
            // document.getElementById("saveMyWorkButton").disabled = false;
        }

        /*
         Tell the iframes to report their state back.
         When all of the iframes have reported back, we will send any changes to the server.
         */
        function updateStatesFromProblems() {
            $('.exercise-iframe').each(function(_, iframe) {
                iframe.contentWindow.postMessage({query: 'getContent', problemId: iframe.id}, '*');
            });
        }


        function sendStateEditScriptToServer(problemId, score, state) {
            if (!problemIdToContent.hasOwnProperty(problemId))
                return;

            const previousScoreString = problemIdToContent[problemId].score !== undefined ?
                    problemIdToContent[problemId].score : "";
            const previousStateString = problemIdToContent[problemId].state !== undefined ?
                    problemIdToContent[problemId].state : "";

            const currentScoreString = score !== undefined ? JSON.stringify(score) : "";
            const currentStateString = state !== undefined ? JSON.stringify(state) : "";

            if (previousScoreString !== currentScoreString || previousStateString !== currentStateString) {
                const data = {
                    problemId: problemId,
                    score: score,
                    stateEditScript: shortestEditScript(previousStateString, currentStateString)
                };

                $.ajax({
                    url: '@preFix/submissions/@assignmentID/@userID',
                    method: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify(data),
                    success: function (msg) {
                        problemIdToContent[problemId] = {
                            score: currentScoreString,
                            state: currentStateString
                        };

                        var response = document.getElementById('response');
                        response.innerHTML = "Your partially complete assignment is saved!";
                        setTimeout(function () {
                            $("#response").hide();
                        }, 5000);
                    },
                    error: function(XMLHttpRequest, textStatus, errorThrown) {
                        alert("Error saving work: " + JSON.stringify(XMLHttpRequest));
                    }
                });
            }
        }

        function receiveMessage(event) {
            console.log("receiveMessage.event=" + JSON.stringify(event));
            if (event.data.request === undefined)
                return;

            const problemId = event.data.request.problemId;
            const score = event.data.score;
            const state = event.data.state;
            sendStateEditScriptToServer(problemId, score, state);
        }

        // Save work and report score
        function submitGrades() {
            updateStatesFromProblems();
            setTimeout(location.href = "@preFix/send-score/@assignmentID/@userID", 1000);
        }

        window.addEventListener("message", receiveMessage, false);

        window.onload = restoreStatesOfProblems;
</script>

@* Timed assignment specific code *@
@if(duration != null && duration > 0L) {
    <script type="text/javascript">
        const durationInMilliseconds = @duration * 60 * 1000;
        const startTimeInMilliseconds = Date.now(); // TODO: Get this number from database

        const endTimeInMilliseconds = startTimeInMilliseconds + durationInMilliseconds;

        function updateTimeLeftDisplay() {
            var timeLeftObj = new Date();
            timeLeftObj.setTime(endTimeInMilliseconds - timeLeftObj.getTime());

            // Time is up, submit assignment
            if (timeLeftObj.getTime() <= 0) {
                submitGrades();
            }

            /*
            All hours and days will be put into minutes
            i.e. two hours and 30 minutes will turn into 150 minutes
             */
            const timeLeftMin = Math.floor((timeLeftObj.getTime() / 1000) / 60);
            const timeLeftSec = timeLeftObj.getSeconds();

            var timeLeftEl = document.getElementById('timeLeft');

            timeLeftEl.innerHTML = "Time Left: " + timeLeftMin + ":" + timeLeftSec;
        }

        updateTimeLeftDisplay();
        setInterval(updateTimeLeftDisplay, 1000);
    </script>

    <div id="timeLeft" class="rightSidebar">
    </div>
}

@* Code to generate the iframes for problems *@
@for(problem <- problems) {
    @if(problemIdToSubmissionWithMostCorrect.contains(problem.getProblemId())) {
        <div style='width: 100% ;
            height: 3em ;
            border: 1px solid black;'
        id="@problemIdToSubmissionWithMostCorrect.get(problem.getProblemId()).getSubmissionId()">
            <p>Highest recorded score:
                <b>@{
                    (problemIdToSubmissionWithMostCorrect.get(problem.getProblemId()).getCorrect().toDouble /
                            problemIdToSubmissionWithMostCorrect.get(problem.getProblemId()).getMaxScore().toDouble) *
                            100
                }%</b> </p>
        </div>
    }

    <iframe style='width: 100% ;
        height: 50em ;' class='exercise-iframe'
    id=@problem.problemId src=@problem.getProblemUrl().trim() ></iframe>
}

<div id='response'></div>
<!-- 
<input disabled id="saveMyWorkButton" type="button" value="Save my work" onclick="updateStatesFromProblems(event)"/>
 -->
<button onclick="submitGrades()">Record my score</button>

<p><!-- If you want to take a break and continue later, click on "Save my work".  -->
    If you are done with all questions, click on "Record my score" to save your score in the gradebook.
</p>

@* Instructor specific code *@
@if(isInstructor) {
    <a href="@routes.HomeController.showEditPage(assignmentID)"><button>Edit Assignment</button></a>
}