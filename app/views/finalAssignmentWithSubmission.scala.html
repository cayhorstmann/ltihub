@import scala.collection.mutable.ListBuffer
@(problems: List[Problem], submissions: List[Submission], assignmentID: Long, userID: String, preFix: String)

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
<script src="@routes.Assets.at("javascripts/shortest-edit-script.js")"></script>

<script type="text/javascript">
        /*
         The states that the server currently has stored.
         This is used to compute what has changed since the last time data was sent to the server, so that the server
         only needs to store the changes every update instead of storing the whole state every update.
         */
        var problemIdToContent = {previous: {}, current: {}};

        // Sends the states of the problems that were previously submitted to the problems to be restored
        function restoreStatesOfProblems() {
            @for(problem <- problems) {
                // Get student's most recently submitted work as a series of changes
                var stateEditScripts = @Html@{
                    val stateEditScriptsList = ListBuffer.empty[String];

                    val submissions = problem.getSubmissions();
                    if (!submissions.isEmpty()) {
                        for (submission <- submissions) {

                            if (submission.getStudentId().equals(userID)
                            && submission.getContent() != null
                            && !submission.getContent().isEmpty()) {
                                stateEditScriptsList += submission.getContent();
                            }
                        }
                    }

                   stateEditScriptsList.mkString("[", ", ", "]");
                };

                // Didn't find submission for given studentID/problemID
                if (!stateEditScripts || stateEditScripts.length === 0) {
                    problemIdToContent.previous["@problem.getProblemId()"] = {};
                } else {
                    // Rebuild state using edit scripts
                    var state = "";
                    for (var i = 0; i < stateEditScripts.length; i++) {
                        var editScript = stateEditScripts[i];

                        state = applyEditScript(state, editScript);
                    }
                    state = JSON.parse(state);

                    // Updates the previous version of the problem content so that we will know what changed
                    problemIdToContent.previous["@problem.getProblemId()"] = {score: {}, state: state};

                    // Post message to iframe to populate the problem
                    var iframe = document.getElementById('@problem.getProblemId()');
                    iframe.contentWindow.postMessage({query: 'restoreState', state: state}, '*');
                }

            }


            setInterval(updateStatesFromProblems, 10000);
        }

        /*
         Tell the iframes to report their state back.
         When all of the iframes have reported back, we will send any changes to the server.
         */
        function updateStatesFromProblems() {
            // Map is reset because the states in the array must be updated after this function is called
            problemIdToContent.current = {};

            $('.exercise-iframe').each(function(_, iframe) {
                iframe.contentWindow.postMessage({query: 'getContent', problemId: iframe.id}, '*');
            });
        }


        function sendStateEditScriptsToServer() {
            messagesSinceLastStatesSentToServer = 0;

            // The problemId, scores, and an edit script to turn the previous submission's state into the current state
            var problemsContents = [];

            for (var problemId in problemIdToContent.current) {
                if (problemIdToContent.previous.hasOwnProperty(problemId) &&
                        problemIdToContent.current.hasOwnProperty(problemId)) {

                    const previousScore = problemIdToContent.previous[problemId].score;
                    const currentScore = problemIdToContent.current[problemId].score;

                    const previousState = problemIdToContent.previous[problemId].state;
                    const currentState = problemIdToContent.current[problemId].state;

                    const previousScoreString = previousScore !== undefined ? JSON.stringify(previousScore) : "";
                    const currentScoreString = currentScore !== undefined ? JSON.stringify(currentScore) : "";

                    const previousStateString = previousState !== undefined ? JSON.stringify(previousState) : "";
                    const currentStateString = currentState !== undefined ? JSON.stringify(currentState) : "";

                    if (previousStateString !== currentStateString || previousScoreString !== currentScoreString) {
                        problemsContents.push({
                            problemId: problemId,
                            score: currentScore,
                            stateEditScript: shortestEditScript(previousStateString, currentStateString)
                        });
                    }
                }
            }

            if (problemsContents.length > 0) {
                $.ajax({
                    url: '@preFix/submissions/@assignmentID',
                    method: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify(problemsContents),
                    success: function (msg) {
                        problemIdToContent.previous = problemIdToContent.current;
                        problemIdToContent.current = {};

                        var response = document.getElementById('response');
                        response.innerHTML = "Your partially complete assignment is saved!";
                        setTimeout(function () {
                            $("#response").hide();
                        }, 5000);
                    }
                });
            }
        }

        var messagesSinceLastStatesSentToServer = 0;
        function receiveMessage(event) {
            messagesSinceLastStatesSentToServer++;

            if (event.data.request !== undefined)
                problemIdToContent.current[event.data.request.problemId] =
                        {score: event.data.score, state: event.data.state};

            const iframes = document.getElementsByClassName('exercise-iframe');
            if (messagesSinceLastStatesSentToServer === iframes.length)
                sendStateEditScriptsToServer();
        }

        window.addEventListener("message", receiveMessage, false);

        window.onload = restoreStatesOfProblems;
</script>

<style>
        .warning {
            background-color: #FFF8C4;
            padding: 1em;
        }
</style>
@if(flash.containsKey("warning")) {
    <p class="warning">
        This LTI tool is launched as an assignment in instructor view.        </p>
}

@for(problem <- problems) {
    @for(submission <- submissions) {
        @if(problem.problemId == submission.problem.problemId) {
            <div style='width: 100% ;
                height: 3em ;
                border: 1px solid black;'
            id= @submission.submissionId >
                <p>You have solved the below problem earlier and highest score from your earlier attempts is :
                    <b>  @submission.correct/ @submission.maxscore</b> </p>
            </div>
        }
    }

    <iframe style='width: 100% ;
        height: 50em ;' class='exercise-iframe'
    id=@problem.problemId src=@problem.getProblemUrl().trim() ></iframe>
}
<div id='response'></div>

<input id="saveMyWorkButton" type="button" value="Save my work" disabled="true" onclick="updateStatesFromProblems(event)"/>
<a href="@routes.GradeSubmitterController.submitGradeToCanvas(assignmentID, userID)"><button>Record my score</button></a>

<p>If you want to take a break and continue later, click on "Save my work". If you are done with all questions, click on "Record my score"</p>

