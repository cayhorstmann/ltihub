@import scala.collection.mutable.ListBuffer
@(problems: List[Problem], submissions: List[Submission], assignmentID: Long, userID: String, preFix: String)

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.2/jquery.min.js"></script>
<script src="@routes.Assets.at("javascripts/shortest-edit-script.js")"></script>

<script type="text/javascript">
        /*
         The states that the server currently has stored.
         This is used to compute what has changed since the last time data was sent to the server, so that the server
         only needs to store the changes every update instead of storing the whole state every update.
         */
        var problemIdToContent = {previous: {}, current: {}};

        // Sends submission to the given iframe to populate its ace editor with the student's previously submitted code
        function populateCodeEditors() {
            @for(problem <- problems) {
            // Get student's most recently submitted work as a series of changes
            var stateEditScripts = @Html@{
                    val stateEditScriptsList = ListBuffer.empty[String];

                    val submissions = problem.getSubmissions();
                    if (!submissions.isEmpty()) {
                        for (submission <- submissions) {

                            if (submission.getStudentId().equals(userID)
                            && submission.getContent() != null
                            && !submission.getContent().isEmpty()) {
                                stateEditScriptsList += submission.getContent();
                            }
                        }
                    }

                   stateEditScriptsList.mkString("[", ", ", "]");
                };

            // Didn't find submission for given studentID/problemID
            if (!stateEditScripts || stateEditScripts.length === 0) {
                return;
            }


            // Rebuild state using edit scripts
            var state = "";
            for (var i = 0; i < stateEditScripts.length; i++) {
                var editScript = stateEditScripts[i];

                state = applyEditScript(state, editScript);
            }
            state = JSON.parse(state);

            // Updates the previous version of the problem content so that we will know what changed
            problemIdToContent.previous[@problem.getProblemId()] = {score: {}, state: state};

            // Post message to iframe to populate the problem
            var iframe = document.getElementById('@problem.getProblemId()');
            iframe.contentWindow.postMessage({query: 'restoreState', state: state}, '*');

            }
        }

        /*
         Tell the iframes to report their state back.
         When all of the iframes have reported back, we will send any changes to the server.
         */
        function updateStatesFromProblems() {
            // Map is reset because the states in the array must be updated after this function is called
            problemIdToContent.current = {};

            $('.exercise-iframe').each(function(_, iframe) {
                iframe.contentWindow.postMessage({query: 'getContent', problemId: iframe.id}, '*');
            });
        }


        function sendStateEditScriptsToServer() {
            // The problemId, scores, and an edit script to turn the previous submission's state into the current state
            var problemsContents = [];

            for (var problemId in problemIdToContent.current) {
                if (problemIdToContent.current.hasOwnProperty(problemId)) {

                    const previousState = problemIdToContent.previous.hasOwnProperty(problemId) ?
                        JSON.stringify(problemIdToContent.previous[problemId].state) : "";
                    const currentState = JSON.stringify(problemIdToContent.current[problemId].state);

                    const previousScore = problemIdToContent.previous.hasOwnProperty(problemId) ?
                            problemIdToContent.previous[problemId].score : "";
                    const currentScore = problemIdToContent.current[problemId].score;

                    if (previousState !== currentState ||
                            JSON.stringify(previousScore) !== JSON.stringify(currentScore)) {
                        problemsContents.push({
                            problemId: problemId,
                            score: currentScore,
                            stateEditScript: shortestEditScript(previousState, currentState)
                        });
                    }
                }
            }

            if (problemsContents.length > 0) {
                $.ajax({
                    url: '@preFix/submissions/@assignmentID',
                    method: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify(problemsContents),
                    success: function (msg) {
                        problemIdToContent.previous = problemIdToContent.current;
                        problemIdToContent.current = {};

                        var response = document.getElementById('response');
                        response.innerHTML = "Your partially complete assignment is saved!";
                        setTimeout(function () {
                            $("#response").hide();
                        }, 5000);
                    }
                });
            }
        }

        function receiveMessage(event) {
            const iframes = document.getElementsByClassName('exercise-iframe');

            if (event.data.query === 'updateProblemContent') {
                problemIdToContent.current[event.data.problemId] = event.data.content;
                if (Object.keys(problemIdToContent.current).length === iframes.length)
                    sendStateEditScriptsToServer();
            }
        }

        window.addEventListener("message", receiveMessage, false);
        setInterval(updateStatesFromProblems, 10000);

        window.onload = populateCodeEditors;
</script>

<style>
        .warning {
            background-color: #FFF8C4;
            padding: 1em;
        }
</style>
@if(flash.containsKey("warning")) {
    <p class="warning">
        This LTI tool is launched as an assignment in instructor view.        </p>
}

@for(problem <- problems) {
    @for(submission <- submissions) {
        @if(problem.problemId == submission.problem.problemId) {
            <div style='width: 100% ;
                height: 3em ;
                border: 1px solid black;'
            id= @submission.submissionId >
                <p>You have solved the below problem earlier and highest score from your earlier attempts is :
                    <b>  @submission.correct/ @submission.maxscore</b> </p>
            </div>
        }
    }

    <iframe style='width: 100% ;
        height: 50em ;' class='exercise-iframe'
    id=@problem.problemId src=@problem.getProblemUrl().trim() ></iframe>
}
<div id='response'></div>

<input type="button" id='btn' value="Save my work" onclick="updateStatesFromProblems(event)"/>
<a href="@routes.GradeSubmitterController.submitGradeToCanvas(assignmentID, userID)"><button>Record my score</button></a>

<p>If you want to take a break and continue later, click on "Save my work". If you are done with all questions, click on "Record my score"</p>

